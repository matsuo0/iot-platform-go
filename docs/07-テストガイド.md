# テストガイド

## 概要

このドキュメントでは、IoT Platform Goプロジェクトのテスト戦略と実装について説明します。

## テスト戦略

### テストピラミッド

```
    E2E Tests (少数)
        /\
       /  \
   Integration Tests (中程度)
      /\
     /  \
Unit Tests (多数)
```

### テストの種類

1. **Unit Tests（単体テスト）**
   - 個々の関数やメソッドのテスト
   - モックを使用して依存関係を分離
   - 高速で信頼性が高い

2. **Integration Tests（統合テスト）**
   - 複数のコンポーネント間の連携テスト
   - 実際のデータベースを使用
   - より現実的なシナリオをテスト

3. **E2E Tests（エンドツーエンドテスト）**
   - 完全なシステムの動作テスト
   - 実際のAPIエンドポイントを使用
   - ユーザーシナリオをテスト

## テストファイル構成

```
├── internal/
│   ├── api/
│   │   ├── device_handler.go
│   │   └── device_handler_test.go      # APIハンドラーのテスト
│   ├── config/
│   │   ├── config.go
│   │   └── config_test.go              # 設定のテスト
│   ├── database/
│   │   ├── database.go
│   │   └── database_test.go            # データベースのテスト
│   └── device/
│       ├── repository.go
│       ├── repository_test.go          # リポジトリのテスト
│       └── mock_repository.go          # モックリポジトリ
├── tests/
│   └── integration_test.go             # 統合テスト
└── pkg/
    └── models/
        ├── device.go
        └── device_test.go              # モデルのテスト
```

## テストの実行

### 基本的なテスト実行

```bash
# すべてのテストを実行
make test

# テストを詳細出力で実行
make test-verbose

# カバレッジレポート付きでテスト実行
make test-coverage

# 特定のテストを実行
make test-specific TEST=TestCreateDevice

# 統合テストのみ実行
make test-integration

# 単体テストのみ実行
make test-unit

# レース検出付きでテスト実行
make test-race

# ベンチマーク実行
make test-bench
```

### テストデータベースのセットアップ

```bash
# テストデータベースのセットアップ
make test-db-setup

# PostgreSQLに接続してテストデータベースを作成
psql -U postgres -h localhost
CREATE DATABASE iot_platform_test;
```

## テストの実装例

### 1. モックリポジトリ

```go
// internal/device/mock_repository.go
type MockRepository struct {
    devices map[string]*models.Device
    createFunc func(req *models.CreateDeviceRequest) (*models.Device, error)
    // ... その他のフィールド
}

func (m *MockRepository) Create(req *models.CreateDeviceRequest) (*models.Device, error) {
    if m.createFunc != nil {
        return m.createFunc(req)
    }
    // デフォルトの実装
    return &models.Device{ID: "mock-id"}, nil
}
```

### 2. APIハンドラーのテスト

```go
// internal/api/device_handler_test.go
func TestCreateDevice(t *testing.T) {
    tests := []struct {
        name           string
        requestBody    string
        mockSetup      func(*device.MockRepository)
        expectedStatus int
        expectedError  string
    }{
        {
            name:        "successful device creation",
            requestBody: `{"name":"Test Device","type":"temperature"}`,
            mockSetup: func(mock *device.MockRepository) {
                mock.SetCreateFunc(func(req *models.CreateDeviceRequest) (*models.Device, error) {
                    return &models.Device{ID: "test-id"}, nil
                })
            },
            expectedStatus: http.StatusCreated,
        },
        // ... その他のテストケース
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // テストの実装
        })
    }
}
```

### 3. リポジトリのテスト

```go
// internal/device/repository_test.go
func TestRepository_Create(t *testing.T) {
    db := setupTestDatabase(t)
    defer db.Close()

    repo := NewRepository(db)

    tests := []struct {
        name    string
        request *models.CreateDeviceRequest
        wantErr bool
    }{
        {
            name:    "successful device creation",
            request: createTestDeviceRequest(),
            wantErr: false,
        },
        // ... その他のテストケース
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            device, err := repo.Create(tt.request)

            if tt.wantErr {
                assert.Error(t, err)
                return
            }

            assert.NoError(t, err)
            assert.NotNil(t, device)
            assert.NotEmpty(t, device.ID)
        })
    }
}
```

### 4. 統合テスト

```go
// tests/integration_test.go
func TestDeviceLifecycle(t *testing.T) {
    server := NewTestServer(t)
    defer server.Close()
    defer server.Cleanup()

    t.Run("complete device lifecycle", func(t *testing.T) {
        // Step 1: Create a device
        createReq := &models.CreateDeviceRequest{
            Name:     "Integration Test Device",
            Type:     "temperature",
            Location: "Test Room",
        }

        createBody, _ := json.Marshal(createReq)
        req := httptest.NewRequest("POST", "/api/devices", bytes.NewBuffer(createBody))
        req.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()

        server.Router.ServeHTTP(w, req)

        assert.Equal(t, http.StatusCreated, w.Code)
        // ... その他の検証
    })
}
```

## テストのベストプラクティス

### 1. テストの命名規則

```go
// 良い例
func TestCreateDevice_Success(t *testing.T)
func TestCreateDevice_InvalidJSON(t *testing.T)
func TestCreateDevice_DatabaseError(t *testing.T)

// 悪い例
func TestCreateDevice1(t *testing.T)
func TestCreateDevice2(t *testing.T)
```

### 2. テストケースの構造

```go
tests := []struct {
    name           string
    input          interface{}
    mockSetup      func()
    expectedOutput interface{}
    expectedError  string
}{
    // テストケース
}
```

### 3. アサーションの使用

```go
import "github.com/stretchr/testify/assert"

// 良い例
assert.NoError(t, err)
assert.Equal(t, expected, actual)
assert.NotNil(t, result)
assert.Contains(t, response, "expected")

// 悪い例
if err != nil {
    t.Fatal(err)
}
if expected != actual {
    t.Errorf("expected %v, got %v", expected, actual)
}
```

### 4. テストデータの管理

```go
// テスト用のヘルパー関数
func createTestDeviceRequest() *models.CreateDeviceRequest {
    return &models.CreateDeviceRequest{
        Name:     "Test Device",
        Type:     "temperature",
        Location: "Test Room",
        Metadata: map[string]interface{}{
            "manufacturer": "Test Corp",
        },
    }
}

func setupTestDatabase(t *testing.T) *database.Database {
    // テストデータベースのセットアップ
}
```

### 5. テストのクリーンアップ

```go
func TestSomething(t *testing.T) {
    // セットアップ
    db := setupTestDatabase(t)
    defer db.Close()
    defer cleanupTestData(t, db)

    // テストの実装
}

func cleanupTestData(t *testing.T, db *database.Database) {
    // テストデータのクリーンアップ
    db.Exec("DELETE FROM devices")
    db.Exec("DELETE FROM device_data")
}
```

## テストカバレッジ

### カバレッジレポートの生成

```bash
# カバレッジレポートを生成
make test-coverage

# ブラウザでカバレッジレポートを開く
open coverage.html
```

### カバレッジの目標

- **Unit Tests**: 80%以上
- **Integration Tests**: 60%以上
- **Overall**: 75%以上

## 継続的インテグレーション

### GitHub Actionsでのテスト実行

プロジェクトには包括的なCI/CDパイプラインが設定されています。

#### ワークフローの内容

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: password
          POSTGRES_DB: iot_platform_test
          POSTGRES_USER: postgres
```

#### 実行されるジョブ

1. **テストジョブ**
   - 依存関係のインストール
   - リンターの実行（golangci-lint）
   - 単体テストの実行
   - 統合テストの実行
   - カバレッジレポートの生成
   - Codecovへのアップロード

2. **ビルドジョブ**
   - アプリケーションのビルド
   - バイナリのアーティファクト保存

3. **セキュリティスキャン**
   - Trivyによる脆弱性スキャン
   - GitHub Security tabへの結果アップロード

4. **Dockerビルド**（mainブランチへのプッシュ時のみ）
   - Dockerイメージのビルド
   - キャッシュの活用

#### 環境変数

CI/CDでは以下の環境変数が設定されます：

```yaml
env:
  DB_HOST: localhost
  DB_PORT: 5432
  DB_NAME: iot_platform_test
  DB_USER: postgres
  DB_PASSWORD: password
  DB_SSL_MODE: disable
```

#### カバレッジレポート

- **HTMLレポート**: アーティファクトとして保存
- **Codecov**: オンラインでのカバレッジ追跡
- **保持期間**: 30日間

#### セキュリティ

- **Trivy**: コンテナイメージとコードの脆弱性スキャン
- **golangci-lint**: セキュリティ関連のリンター
- **GitHub Security**: セキュリティ問題の追跡

#### ローカルでのCI/CDテスト

```bash
# リンターの実行
make lint

# テストの実行
make test-coverage

# ビルドの確認
make build

# Dockerビルドの確認
docker build -t iot-platform-go .
```

#### PRでのチェック

PRを作成すると、以下のチェックが自動実行されます：

1. ✅ **Lint**: コードスタイルと品質チェック
2. ✅ **Test**: 単体テストと統合テスト
3. ✅ **Build**: アプリケーションのビルド
4. ✅ **Security**: セキュリティスキャン
5. ✅ **Coverage**: テストカバレッジの確認

#### 失敗時の対処

CI/CDが失敗した場合：

1. **ローカルでの確認**
   ```bash
   make check  # フォーマット、リンター、テストを実行
   ```

2. **ログの確認**
   - GitHub Actionsのログを確認
   - エラーメッセージを詳細に読む

3. **一般的な問題**
   - インポートの整理: `go mod tidy`
   - フォーマット: `make fmt`
   - リンターエラー: `.golangci.yml`の設定確認

#### カスタマイズ

CI/CDパイプラインのカスタマイズ：

1. **`.github/workflows/ci.yml`**: メインのワークフロー
2. **`.golangci.yml`**: リンターの設定
3. **`Dockerfile`**: Dockerビルドの設定

#### ベストプラクティス

1. **PRの前にローカルテスト**
   ```bash
   make check
   ```

2. **小さなPR**
   - 1つの機能に集中
   - レビューしやすいサイズ

3. **テストの追加**
   - 新機能には必ずテストを追加
   - カバレッジの維持

4. **セキュリティの考慮**
   - 依存関係の更新
   - セキュリティスキャンの確認 