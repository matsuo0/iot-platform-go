# テストガイド

## 概要

このドキュメントでは、IoT Platform Goプロジェクトのテスト戦略と実装について説明します。

## テスト戦略

### テストピラミッド

```
    E2E Tests (少数)
        /\
       /  \
   Integration Tests (中程度)
      /\
     /  \
Unit Tests (多数)
```

### テストの種類

1. **Unit Tests（単体テスト）**
   - 個々の関数やメソッドのテスト
   - モックを使用して依存関係を分離
   - 高速で信頼性が高い

2. **Integration Tests（統合テスト）**
   - 複数のコンポーネント間の連携テスト
   - 実際のデータベースを使用
   - より現実的なシナリオをテスト

3. **E2E Tests（エンドツーエンドテスト）**
   - 完全なシステムの動作テスト
   - 実際のAPIエンドポイントを使用
   - ユーザーシナリオをテスト

## テストファイル構成

```
├── internal/
│   ├── api/
│   │   ├── device_handler.go
│   │   └── device_handler_test.go      # APIハンドラーのテスト
│   ├── config/
│   │   ├── config.go
│   │   └── config_test.go              # 設定のテスト
│   ├── database/
│   │   ├── database.go
│   │   └── database_test.go            # データベースのテスト
│   └── device/
│       ├── repository.go
│       ├── repository_test.go          # リポジトリのテスト
│       └── mock_repository.go          # モックリポジトリ
├── tests/
│   └── integration_test.go             # 統合テスト
└── pkg/
    └── models/
        ├── device.go
        └── device_test.go              # モデルのテスト
```

## テストの実行

### 基本的なテスト実行

```bash
# すべてのテストを実行
make test

# テストを詳細出力で実行
make test-verbose

# カバレッジレポート付きでテスト実行
make test-coverage

# 特定のテストを実行
make test-specific TEST=TestCreateDevice

# 統合テストのみ実行
make test-integration

# 単体テストのみ実行
make test-unit

# レース検出付きでテスト実行
make test-race

# ベンチマーク実行
make test-bench
```

### テストデータベースのセットアップ

```bash
# テストデータベースのセットアップ
make test-db-setup

# PostgreSQLに接続してテストデータベースを作成
psql -U postgres -h localhost
CREATE DATABASE iot_platform_test;
```

## テストの実装例

### 1. モックリポジトリ

```go
// internal/device/mock_repository.go
type MockRepository struct {
    devices map[string]*models.Device
    createFunc func(req *models.CreateDeviceRequest) (*models.Device, error)
    // ... その他のフィールド
}

func (m *MockRepository) Create(req *models.CreateDeviceRequest) (*models.Device, error) {
    if m.createFunc != nil {
        return m.createFunc(req)
    }
    // デフォルトの実装
    return &models.Device{ID: "mock-id"}, nil
}
```

### 2. APIハンドラーのテスト

```go
// internal/api/device_handler_test.go
func TestCreateDevice(t *testing.T) {
    tests := []struct {
        name           string
        requestBody    string
        mockSetup      func(*device.MockRepository)
        expectedStatus int
        expectedError  string
    }{
        {
            name:        "successful device creation",
            requestBody: `{"name":"Test Device","type":"temperature"}`,
            mockSetup: func(mock *device.MockRepository) {
                mock.SetCreateFunc(func(req *models.CreateDeviceRequest) (*models.Device, error) {
                    return &models.Device{ID: "test-id"}, nil
                })
            },
            expectedStatus: http.StatusCreated,
        },
        // ... その他のテストケース
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // テストの実装
        })
    }
}
```

### 3. リポジトリのテスト

```go
// internal/device/repository_test.go
func TestRepository_Create(t *testing.T) {
    db := setupTestDatabase(t)
    defer db.Close()

    repo := NewRepository(db)

    tests := []struct {
        name    string
        request *models.CreateDeviceRequest
        wantErr bool
    }{
        {
            name:    "successful device creation",
            request: createTestDeviceRequest(),
            wantErr: false,
        },
        // ... その他のテストケース
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            device, err := repo.Create(tt.request)

            if tt.wantErr {
                assert.Error(t, err)
                return
            }

            assert.NoError(t, err)
            assert.NotNil(t, device)
            assert.NotEmpty(t, device.ID)
        })
    }
}
```

### 4. 統合テスト

```go
// tests/integration_test.go
func TestDeviceLifecycle(t *testing.T) {
    server := NewTestServer(t)
    defer server.Close()
    defer server.Cleanup()

    t.Run("complete device lifecycle", func(t *testing.T) {
        // Step 1: Create a device
        createReq := &models.CreateDeviceRequest{
            Name:     "Integration Test Device",
            Type:     "temperature",
            Location: "Test Room",
        }

        createBody, _ := json.Marshal(createReq)
        req := httptest.NewRequest("POST", "/api/devices", bytes.NewBuffer(createBody))
        req.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()

        server.Router.ServeHTTP(w, req)

        assert.Equal(t, http.StatusCreated, w.Code)
        // ... その他の検証
    })
}
```

## テストのベストプラクティス

### 1. テストの命名規則

```go
// 良い例
func TestCreateDevice_Success(t *testing.T)
func TestCreateDevice_InvalidJSON(t *testing.T)
func TestCreateDevice_DatabaseError(t *testing.T)

// 悪い例
func TestCreateDevice1(t *testing.T)
func TestCreateDevice2(t *testing.T)
```

### 2. テストケースの構造

```go
tests := []struct {
    name           string
    input          interface{}
    mockSetup      func()
    expectedOutput interface{}
    expectedError  string
}{
    // テストケース
}
```

### 3. アサーションの使用

```go
import "github.com/stretchr/testify/assert"

// 良い例
assert.NoError(t, err)
assert.Equal(t, expected, actual)
assert.NotNil(t, result)
assert.Contains(t, response, "expected")

// 悪い例
if err != nil {
    t.Fatal(err)
}
if expected != actual {
    t.Errorf("expected %v, got %v", expected, actual)
}
```

### 4. テストデータの管理

```go
// テスト用のヘルパー関数
func createTestDeviceRequest() *models.CreateDeviceRequest {
    return &models.CreateDeviceRequest{
        Name:     "Test Device",
        Type:     "temperature",
        Location: "Test Room",
        Metadata: map[string]interface{}{
            "manufacturer": "Test Corp",
        },
    }
}

func setupTestDatabase(t *testing.T) *database.Database {
    // テストデータベースのセットアップ
}
```

### 5. テストのクリーンアップ

```go
func TestSomething(t *testing.T) {
    // セットアップ
    db := setupTestDatabase(t)
    defer db.Close()
    defer cleanupTestData(t, db)

    // テストの実装
}

func cleanupTestData(t *testing.T, db *database.Database) {
    // テストデータのクリーンアップ
    db.Exec("DELETE FROM devices")
    db.Exec("DELETE FROM device_data")
}
```

## テストカバレッジ

### カバレッジレポートの生成

```bash
# カバレッジレポートを生成
make test-coverage

# ブラウザでカバレッジレポートを開く
open coverage.html
```

### カバレッジの目標

- **Unit Tests**: 80%以上
- **Integration Tests**: 60%以上
- **Overall**: 75%以上

## 継続的インテグレーション

### GitHub Actionsでのテスト実行

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: password
          POSTGRES_DB: iot_platform_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
    
    - name: Install dependencies
      run: make deps
    
    - name: Run tests
      run: make test-coverage
      env:
        DB_HOST: localhost
        DB_PORT: 5432
        DB_NAME: iot_platform_test
        DB_USER: postgres
        DB_PASSWORD: password
        DB_SSL_MODE: disable
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
```

## トラブルシューティング

### よくある問題と解決方法

#### 1. データベース接続エラー

```bash
# PostgreSQLが起動していることを確認
docker-compose up -d postgres

# テストデータベースが存在することを確認
psql -U postgres -h localhost -d iot_platform_test -c "SELECT 1;"
```

#### 2. テストが遅い

```bash
# 並列テストを有効にする
go test -parallel 4 ./...

# 特定のテストのみ実行
make test-specific TEST=TestCreateDevice
```

#### 3. モックが期待通りに動作しない

```go
// モックの設定を確認
mockRepo := device.NewMockRepository()
mockRepo.SetCreateFunc(func(req *models.CreateDeviceRequest) (*models.Device, error) {
    return &models.Device{ID: "test-id"}, nil
})

// モックが正しく注入されていることを確認
handler := api.NewDeviceHandler(mockRepo)
```

## まとめ

このテストガイドに従うことで、以下の利点が得られます：

1. **品質の向上**: バグの早期発見と修正
2. **リファクタリングの安全性**: 既存機能の破壊を防ぐ
3. **ドキュメントとしての役割**: コードの使用方法を明確化
4. **開発速度の向上**: デバッグ時間の短縮
5. **信頼性の向上**: 本番環境での問題を減らす

テストは開発プロセスの重要な一部であり、継続的に改善していく必要があります。 