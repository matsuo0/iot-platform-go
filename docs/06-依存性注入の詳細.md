# 依存性注入の詳細解説

## 概要

依存性注入（Dependency Injection）は、オブジェクトが必要とする依存関係を外部から提供する設計パターンです。Phase 1の実装では、このパターンを使用してクリーンアーキテクチャを実現しています。

## 基本概念

### 依存性注入とは

依存性注入は、クラスが直接依存関係を作成するのではなく、外部から依存関係を受け取るパターンです。

#### 問題のある実装（依存性注入なし）
```go
// ❌ 悪い例：直接依存
type DeviceHandler struct {
    repo *device.Repository
}

func NewDeviceHandler() *DeviceHandler {
    // ハードコードされた依存関係
    db := database.New(config.Load())
    repo := device.NewRepository(db)
    return &DeviceHandler{repo: repo}
}
```

#### 良い実装（依存性注入あり）
```go
// ✅ 良い例：依存性注入
type DeviceHandler struct {
    repo *device.Repository
}

func NewDeviceHandler(repo *device.Repository) *DeviceHandler {
    return &DeviceHandler{repo: repo} // 外部から注入
}
```

## Phase 1での依存性注入の実装

### 1. 依存関係の図

```
main.go
    ↓ (依存)
config.Load()
    ↓ (依存)
database.New(cfg)
    ↓ (依存)
device.NewRepository(db)
    ↓ (依存)
api.NewDeviceHandler(deviceRepo)
    ↓ (依存)
gin.Router
```

### 2. 実装の詳細

#### ステップ1: 設定の読み込み
```go
// main.go
func main() {
    // 設定オブジェクトの作成
    cfg := config.Load()
    
    // 以降のステップで使用
}
```

#### ステップ2: データベース接続の作成
```go
// main.go
func main() {
    cfg := config.Load()
    
    // 設定をデータベース接続に注入
    db, err := database.New(cfg)
    if err != nil {
        log.Fatalf("Failed to initialize database: %v", err)
    }
    defer db.Close()
}
```

#### ステップ3: リポジトリの作成
```go
// main.go
func main() {
    // ... 前のステップ
    
    // データベース接続をリポジトリに注入
    deviceRepo := device.NewRepository(db)
}
```

#### ステップ4: ハンドラーの作成
```go
// main.go
func main() {
    // ... 前のステップ
    
    // リポジトリをハンドラーに注入
    deviceHandler := api.NewDeviceHandler(deviceRepo)
}
```

### 3. 各レイヤーでの実装

#### Presentation Layer（APIハンドラー）
```go
// internal/api/device_handler.go
type DeviceHandler struct {
    repo *device.Repository // 依存関係をフィールドとして保持
}

// コンストラクタで依存関係を注入
func NewDeviceHandler(repo *device.Repository) *DeviceHandler {
    return &DeviceHandler{repo: repo}
}

// 注入された依存関係を使用
func (h *DeviceHandler) CreateDevice(c *gin.Context) {
    var req models.CreateDeviceRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body: " + err.Error()})
        return
    }

    // 注入されたリポジトリを使用
    device, err := h.repo.Create(&req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create device: " + err.Error()})
        return
    }

    c.JSON(http.StatusCreated, device)
}
```

#### Application Layer（リポジトリ）
```go
// internal/device/repository.go
type Repository struct {
    db *database.Database // 依存関係をフィールドとして保持
}

// コンストラクタで依存関係を注入
func NewRepository(db *database.Database) *Repository {
    return &Repository{db: db}
}

// 注入された依存関係を使用
func (r *Repository) Create(req *models.CreateDeviceRequest) (*models.Device, error) {
    device := &models.Device{
        ID:        uuid.New().String(),
        Name:      req.Name,
        Type:      req.Type,
        Location:  req.Location,
        Status:    "offline",
        LastSeen:  time.Now(),
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
        Metadata:  req.Metadata,
    }

    query := `
        INSERT INTO devices (id, name, type, location, status, last_seen, created_at, updated_at, metadata)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `

    // 注入されたデータベース接続を使用
    _, err := r.db.Exec(query, device.ID, device.Name, device.Type, device.Location,
        device.Status, device.LastSeen, device.CreatedAt, device.UpdatedAt, device.Metadata)
    if err != nil {
        return nil, fmt.Errorf("failed to create device: %w", err)
    }

    return device, nil
}
```

## 依存性注入の利点

### 1. テストの容易さ

#### モックリポジトリの作成
```go
// テスト用のモックリポジトリ
type MockRepository struct {
    devices []*models.Device
    createFunc func(req *models.CreateDeviceRequest) (*models.Device, error)
    getByIDFunc func(id string) (*models.Device, error)
    getAllFunc func() ([]*models.Device, error)
}

func (m *MockRepository) Create(req *models.CreateDeviceRequest) (*models.Device, error) {
    if m.createFunc != nil {
        return m.createFunc(req)
    }
    return &models.Device{ID: "test-id"}, nil
}

func (m *MockRepository) GetByID(id string) (*models.Device, error) {
    if m.getByIDFunc != nil {
        return m.getByIDFunc(id)
    }
    return &models.Device{ID: id}, nil
}

func (m *MockRepository) GetAll() ([]*models.Device, error) {
    if m.getAllFunc != nil {
        return m.getAllFunc()
    }
    return m.devices, nil
}
```

#### テストでの使用
```go
func TestCreateDevice(t *testing.T) {
    // モックリポジトリの作成
    mockRepo := &MockRepository{
        createFunc: func(req *models.CreateDeviceRequest) (*models.Device, error) {
            return &models.Device{
                ID:       "test-id",
                Name:     req.Name,
                Type:     req.Type,
                Location: req.Location,
            }, nil
        },
    }
    
    // モックをハンドラーに注入
    handler := api.NewDeviceHandler(mockRepo)
    
    // テスト用のGinコンテキスト作成
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    
    // テストデータの設定
    jsonData := `{"name":"Test Device","type":"temperature","location":"Test Room"}`
    c.Request = httptest.NewRequest("POST", "/api/devices", strings.NewReader(jsonData))
    c.Request.Header.Set("Content-Type", "application/json")
    
    // テスト実行
    handler.CreateDevice(c)
    
    // 結果の検証
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response models.Device
    err := json.Unmarshal(w.Body.Bytes(), &response)
    assert.NoError(t, err)
    assert.Equal(t, "Test Device", response.Name)
}
```

### 2. 柔軟性の向上

#### 異なる実装の切り替え
```go
func main() {
    cfg := config.Load()
    
    var repo device.Repository
    
    // 環境に応じて実装を切り替え
    switch cfg.Environment {
    case "test":
        repo = &MockRepository{} // テスト用
    case "development":
        db, _ := database.New(cfg)
        repo = device.NewRepository(db) // 開発用
    case "production":
        db, _ := database.New(cfg)
        repo = device.NewRepository(db) // 本番用
    }
    
    handler := api.NewDeviceHandler(repo)
    // ...
}
```

### 3. 結合度の低下

#### インターフェースベースの依存性注入
```go
// インターフェース定義
type Repository interface {
    Create(req *models.CreateDeviceRequest) (*models.Device, error)
    GetByID(id string) (*models.Device, error)
    GetAll() ([]*models.Device, error)
    Update(id string, req *models.UpdateDeviceRequest) (*models.Device, error)
    Delete(id string) error
    UpdateStatus(id string, status string) error
}

// ハンドラーはインターフェースに依存
type DeviceHandler struct {
    repo Repository // 具体的な実装ではなくインターフェースに依存
}

func NewDeviceHandler(repo Repository) *DeviceHandler {
    return &DeviceHandler{repo: repo}
}
```

## より高度な依存性注入の実装

### 1. 依存性注入コンテナの使用

#### シンプルなDIコンテナ
```go
// internal/container/container.go
type Container struct {
    services map[string]interface{}
}

func NewContainer() *Container {
    return &Container{
        services: make(map[string]interface{}),
    }
}

func (c *Container) Register(name string, service interface{}) {
    c.services[name] = service
}

func (c *Container) Get(name string) interface{} {
    return c.services[name]
}

// 使用例
func main() {
    container := container.NewContainer()
    
    // 依存関係の登録
    cfg := config.Load()
    container.Register("config", cfg)
    
    db, _ := database.New(cfg)
    container.Register("database", db)
    
    repo := device.NewRepository(db)
    container.Register("deviceRepository", repo)
    
    handler := api.NewDeviceHandler(repo)
    container.Register("deviceHandler", handler)
    
    // 使用
    handler := container.Get("deviceHandler").(*api.DeviceHandler)
}
```

### 2. ファクトリーパターンの使用

#### ファクトリー関数
```go
// internal/factory/device_factory.go
type DeviceFactory struct {
    db *database.Database
}

func NewDeviceFactory(db *database.Database) *DeviceFactory {
    return &DeviceFactory{db: db}
}

func (f *DeviceFactory) CreateRepository() *device.Repository {
    return device.NewRepository(f.db)
}

func (f *DeviceFactory) CreateHandler() *api.DeviceHandler {
    repo := f.CreateRepository()
    return api.NewDeviceHandler(repo)
}

// 使用例
func main() {
    cfg := config.Load()
    db, _ := database.New(cfg)
    
    factory := factory.NewDeviceFactory(db)
    handler := factory.CreateHandler()
    
    // ...
}
```

### 3. 設定ベースの依存性注入

#### 設定ファイルでの依存関係定義
```yaml
# configs/dependencies.yaml
dependencies:
  database:
    type: postgresql
    config:
      host: localhost
      port: 5432
      name: iot_platform
      user: postgres
      password: password
  
  repositories:
    device:
      type: postgresql
      database: database
  
  handlers:
    device:
      type: http
      repository: device
```

#### 設定ベースのDI実装
```go
// internal/container/config_based.go
type ConfigBasedContainer struct {
    config *config.Config
    services map[string]interface{}
}

func NewConfigBasedContainer(cfg *config.Config) *ConfigBasedContainer {
    return &ConfigBasedContainer{
        config: cfg,
        services: make(map[string]interface{}),
    }
}

func (c *ConfigBasedContainer) Initialize() error {
    // データベースの初期化
    db, err := database.New(c.config)
    if err != nil {
        return err
    }
    c.services["database"] = db
    
    // リポジトリの初期化
    deviceRepo := device.NewRepository(db)
    c.services["deviceRepository"] = deviceRepo
    
    // ハンドラーの初期化
    deviceHandler := api.NewDeviceHandler(deviceRepo)
    c.services["deviceHandler"] = deviceHandler
    
    return nil
}

func (c *ConfigBasedContainer) Get(name string) interface{} {
    return c.services[name]
}
```

## ベストプラクティス

### 1. インターフェースの使用
- 具体的な実装ではなく、インターフェースに依存する
- テストとモックが容易になる

### 2. コンストラクタ注入
- 依存関係はコンストラクタで注入する
- オブジェクトの作成時に必要な依存関係が明確になる

### 3. 循環依存の回避
- 依存関係の方向を一方向にする
- クリーンアーキテクチャの原則に従う

### 4. 適切なスコープ
- 依存関係のライフサイクルを適切に管理する
- シングルトン、スコープ付き、トランジェントの使い分け

## まとめ

Phase 1の実装では、依存性注入を使用して以下の利点を実現しています：

1. **テストの容易さ**: モックオブジェクトを使用した単体テスト
2. **柔軟性**: 異なる実装の簡単な切り替え
3. **保守性**: 結合度の低下による保守性の向上
4. **拡張性**: 新しい機能の追加が容易

この設計により、Phase 2以降の機能追加（MQTT、WebSocket等）も、既存のコードに影響を与えることなく実装できます。 